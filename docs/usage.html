<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>tccp - usage</title>
<link rel="stylesheet" href="style.css">
<link rel="icon" href="logo.png" type="image/png">
</head>
<body>
<h1>usage</h1>
<nav>
<a href="index.html">home</a>
<a href="install.html">install</a>
<a href="usage.html">usage</a>
<a href="commands.html">commands</a>
<a href="settings.html">settings</a>
<a href="architecture.html">how it works</a>
<a href="contact.html">contact</a>
</nav>

<h2>prerequisites</h2>
<p>
You need access to the Tufts HPC cluster before using tccp.
<a href="https://tufts.qualtrics.com/jfe/form/SV_5bUmpFT0IXeyEfj">Request access here</a> if you haven't already.
The <a href="https://rtguides.it.tufts.edu/hpc/index.html">Tufts HPC documentation</a> is a good reference for the cluster itself.
</p>

<h2>getting started</h2>
<p class="note">
You need to be on the Tufts network (campus WiFi or <a href="https://it.tufts.edu/guides/tufts-vpn-virtual-private-network/vpn-desktop-application">Cisco AnyConnect VPN</a>).
On campus WiFi, you'll need to approve a Duo push every time you connect. The VPN avoids this.
</p>
<pre>
$ tccp setup              <span class="c"># save credentials (one time)</span>
$ cd my-ml-project
$ tccp register           <span class="c"># set up your project (one time)</span>
$ tccp                    <span class="c"># connect</span>
</pre>

<h2>tccp.yaml</h2>
<p>
Lives in your project root. <code>tccp register</code> creates it for you,
or write it by hand. Everything is optional &mdash; see
<a href="settings.html">settings</a> for the full reference.
</p>
<pre>
type: python-pytorch
gpu: a100
env: .env
output: output
cache: cache

jobs:
  train:
    script: train.py
    args: "--lr 0.001"
    time: "4:00:00"
    ports: [6006]
</pre>
<p>
Put API keys in a <code>.env</code> file &mdash; tccp syncs it automatically
and it's never tracked by git.
</p>

<h2>running jobs</h2>
<p>
Type <code>run train</code> and tccp handles the rest: finds or creates a
SLURM allocation, sets up the environment, syncs your code, and launches.
This happens in the background so you can keep using the REPL. You can
pass extra arguments inline or run multiple jobs at once.
</p>
<pre>
tccp> run train --epochs 100 --batch-size 64
tccp> run eval
</pre>

<h2>viewing output</h2>
<p>
When a job is running, <code>view</code> attaches you to the live output
stream. <code>Ctrl+C</code> cancels the job, <code>Ctrl+\</code> detaches
(job keeps running &mdash; reattach anytime with <code>view</code> again).
<code>Ctrl+V</code> opens the full output buffer in your text editor
(vim on macOS/Linux, nano on Windows) for searching and scrolling. You can
also use the <code>output</code> command to do the same thing from the REPL.
</p>

<!-- terminal mockup -->
<svg viewBox="0 0 720 340" xmlns="http://www.w3.org/2000/svg" style="width:100%;max-width:720px;margin:16px 0;border-radius:8px;overflow:hidden;">
  <rect width="720" height="340" fill="#0c0c0c"/>
  <rect width="720" height="28" fill="#222"/>
  <circle cx="16" cy="14" r="5" fill="#ff5f56"/>
  <circle cx="34" cy="14" r="5" fill="#ffbd2e"/>
  <circle cx="52" cy="14" r="5" fill="#27c93f"/>
  <text x="360" y="18" text-anchor="middle" fill="#888" font-family="monospace" font-size="11">Terminal</text>
  <text x="14" y="54" fill="#c8b896" font-family="monospace" font-size="12">Epoch 1/50  loss=2.4183  acc=0.312  lr=0.001</text>
  <text x="14" y="72" fill="#c8b896" font-family="monospace" font-size="12">Epoch 2/50  loss=1.8741  acc=0.445  lr=0.001</text>
  <text x="14" y="90" fill="#c8b896" font-family="monospace" font-size="12">Epoch 3/50  loss=1.5029  acc=0.521  lr=0.001</text>
  <text x="14" y="108" fill="#c8b896" font-family="monospace" font-size="12">Epoch 4/50  loss=1.2156  acc=0.598  lr=0.001</text>
  <text x="14" y="126" fill="#c8b896" font-family="monospace" font-size="12">Epoch 5/50  loss=0.9847  acc=0.654  lr=0.001</text>
  <text x="14" y="144" fill="#c8b896" font-family="monospace" font-size="12">Epoch 6/50  loss=0.8213  acc=0.701  lr=0.001</text>
  <text x="14" y="162" fill="#c8b896" font-family="monospace" font-size="12">Epoch 7/50  loss=0.7104  acc=0.733  lr=0.001</text>
  <text x="14" y="180" fill="#c8b896" font-family="monospace" font-size="12">Epoch 8/50  loss=0.6241  acc=0.758  lr=0.0005</text>
  <text x="14" y="198" fill="#c8b896" font-family="monospace" font-size="12">Epoch 9/50  loss=0.5518  acc=0.779  lr=0.0005</text>
  <text x="14" y="216" fill="#c8b896" font-family="monospace" font-size="12">Epoch 10/50 loss=0.4932  acc=0.801  lr=0.0005</text>
  <text x="14" y="234" fill="#c8b896" font-family="monospace" font-size="12">Epoch 11/50 loss=0.4471  acc=0.815  lr=0.0005</text>
  <text x="14" y="252" fill="#c8b896" font-family="monospace" font-size="12">Epoch 12/50 loss=0.4089  acc=0.828  lr=0.0005</text>
  <rect x="14" y="260" width="8" height="14" fill="#c8b896" opacity="0.7">
    <animate attributeName="opacity" values="0.7;0;0.7" dur="1.2s" repeatCount="indefinite"/>
  </rect>
  <rect y="284" width="720" height="26" fill="#3e3e3e"/>
  <text x="10" y="302" fill="#3e78b2" font-family="monospace" font-size="12" font-weight="bold">tccp</text>
  <text x="42" y="302" fill="#b2b2b2" font-family="monospace" font-size="12"> | train | SLURM:48291 | c0178</text>
  <rect y="310" width="720" height="30" fill="#55483e"/>
  <text x="10" y="330" fill="#c8b896" font-family="monospace" font-size="12">RUNNING</text>
  <text x="390" y="330" fill="#787878" font-family="monospace" font-size="11">Ctrl+C cancel  Ctrl+\ detach  Ctrl+V output</text>
</svg>

<h2>interactive shell</h2>
<p>
<code>open</code> drops you into a bash shell on the compute node, inside
the same container as your job. Your code, venv, and env vars are all there.
</p>
<pre>
tccp> open train
train@c0178> python -c "import torch; print(torch.cuda.is_available())"
True
</pre>

<h2>disconnects and output</h2>
<p>
Jobs survive disconnects. If your laptop sleeps or your WiFi drops, the
job keeps running. Reconnect with <code>tccp</code> and everything is
still there. When a job finishes, output is downloaded to your machine
automatically &mdash; if you're offline, it downloads next time you connect.
</p>

<h2>allocations</h2>
<p>
tccp reuses SLURM allocations across jobs. If you run a second job that
needs the same resources, it skips the queue and launches instantly.
When you exit tccp, idle allocations are released automatically.
You can also manage them manually with <code>allocs</code> and
<code>dealloc</code>.
</p>

<h2>port forwarding</h2>
<p>
Declare ports in your config and they're forwarded to localhost automatically.
No SSH tunnel setup &mdash; just open <code>http://localhost:6006</code>.
</p>
<pre>
jobs:
  train:
    script: train.py
    ports: [6006]
</pre>

<h2>expected timing</h2>
<p>
When you <code>run &lt;job&gt;</code>, initialization happens in the background.
The first run for a new project is the slowest because the container image and
environment must be set up. After that, everything is cached and re-runs are fast.
</p>
<table>
<tr><th>Stage</th><th>First run</th><th>Re-runs</th></tr>
<tr><td>SLURM allocation</td><td>10&ndash;120s</td><td>0s (reused)</td></tr>
<tr><td>Container pull</td><td>5&ndash;15 min</td><td>0s (cached)</td></tr>
<tr><td>Venv creation</td><td>20&ndash;30s</td><td>0s (cached)</td></tr>
<tr><td>Tool install (uv, dtach)</td><td>5&ndash;15s</td><td>0s (cached)</td></tr>
<tr><td>File sync</td><td>2&ndash;30s (full)</td><td>1&ndash;3s (incremental)</td></tr>
<tr><td>Requirements (uv)</td><td>5&ndash;30s</td><td>0s (cached by hash)</td></tr>
<tr><td>Job launch</td><td>1&ndash;2s</td><td>1&ndash;2s</td></tr>
<tr><td><b>Total</b></td><td><b>~1&ndash;20 min</b></td><td><b>3&ndash;10s</b></td></tr>
</table>
<p>
Use <code>initlogs &lt;job&gt;</code> to see real-time progress of each stage.
</p>

<h2>good to know</h2>
<p>
Your <code>.gitignore</code> (or <code>.tccpignore</code>) controls which
files get synced &mdash; keep large data out. <code>requirements.txt</code>
is installed automatically and cached by hash, so unchanged deps are a no-op.
If you edit <code>tccp.yaml</code>, type <code>refresh</code> to pick up
changes without reconnecting.
</p>

</body>
</html>
